---
title: "Analyse multi-omique"
author: "Imbert Pierre, Margerit William & Pretet Maël"
date: "`r format(Sys.time(), '%d/%m/%y')`"
output:
  bookdown::html_document2:
    df_print: paged
    toc: yes
    toc_depth: '3'
    #toc_float: 
    #  collapsed: true
    theme: default # “default”, “cerulean”, “united”, “cosmo”
    fig_caption: true
header-includes:
  \usepackage{float}
editor_options:
  chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, include=FALSE, cache=FALSE, fig.align="center", fig.show="asis", fig.pos="H")
```

```{r library_installation, eval=F, message=FALSE, warning=FALSE}
#install.packages("tidyverse")

#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("mixOmics")
#BiocManager::install("timeOmics")
```

```{r library_load, message=FALSE, warning=FALSE}
#library("tidyverse")
library("mixOmics")
#library("timeOmics")
```

https://adcloud.compbio.ulaval.ca/index.php/s/SdDrKrkbq9QHCLn


# Partie I

```{r}
mirna = read.csv("ParisDiderot_202010/mirna.csv", header = T)
row.names(mirna) = mirna[,1]
mirna = mirna[,-1]
dim(mirna)

mrna = read.csv("ParisDiderot_202010/mrna.csv", header = T)
row.names(mrna) = mrna[,1]
mrna = mrna[,-1]
dim(mrna)

prot = read.csv("ParisDiderot_202010/protein.csv", header = T)
row.names(prot) = prot[,1]
prot = prot[,-1]
dim(prot)

sample = read.csv("ParisDiderot_202010/sample_group.csv", header = T)
dim(sample)
```

Pour les protéines, miRNA et gènes, on possède les données de 150 échantillons. On a ensuite 142 variables pour les protéines, 184 pour les miRNA et 200 pour les gènes.

## Analyse variation
```{r}
coeff_variation = function(vec){
  return(sd(vec) / mean(vec))
}
```


```{r, include=T, out.width="80%", out.height="80%", fig.cap="Distribution du coefficient de variation dans le bloc mirna"}
truehist(apply(mirna, 2, coeff_variation), xlab = "mirna", col="#8b1538")
```

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Distribution du coefficient de variation dans le blocs mrna"}
truehist(apply(mrna, 2, coeff_variation), xlab = "mrna", col="#8b1538")
```

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Distribution du coefficient de variation dans le bloc protéine"}
truehist(apply(prot, 2, coeff_variation), xlab = "Proteine", col="#8b1538")
```

On peut voir sur les histogrammes que le type de données possédant le plus de variabilité est le type protéine. En effet, sa variabilité est comprise entre -100 et 250, même si on peut observer qu'elle est comme les autres centrée vers 0.


## Nettoyage des données
```{r}
mirna.c = mirna[,which(abs(apply(mirna, 2, coeff_variation)) >= 0.15)]
dim(mirna)
dim(mirna.c)

mrna.c = mrna[,which(abs(apply(mrna, 2, coeff_variation)) >= 0.15)]
dim(mrna)
dim(mrna.c)

prot.c = prot[,which(abs(apply(prot, 2, coeff_variation)) >= 0.15)]
dim(prot)
dim(prot.c)
```

En supprimant les données les plus variantes ($\lvert{C_v}\rvert \geq 0.15$), il ne reste que 142 protéines, 174 gènes et 82 miRNA.

## Gène le plus variable

Le gène avec le plus grand coefficient de variance de notre jeu de données est PLCD4. La protéine codée par ce gène peut jouer un rôle dans la croissance et la prolifération cellulaire. Son expression peut donc notamment être un marqueur de cancer. 
PLCD4 est situé sur le chromosome 2, et sa longueur est de 30749 nucléotides.
La protéine correspondant à ce gène est Q9BRC7, d'une longueur de 762 nucléotides, mais n'est pas contenue dans notre jeu de données.

# Partie II

## 1. Single-omic: l’ACP avec mixOmics

L'ACP est une méthode d'analyse statistique et de réduction des données, permettant de calculer des composantes maximisant la variabilité des données étudiées. On peut ensuite évaluer si les composantes calculées permettent de caractériser correctement la variabilité des données (par exemple s'il est possible de retrouver certains groupes séparés distinctement par les composantes), et d'identifier les variables les plus importantes participant à ces composantes.

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Explication de la variabilité par les différentes composantes - avec center & scale false"}
mrna.pca = tune.pca(X = mrna.c, ncomp = 50, center = F, scale = F)
mrna.pca
```
Au vu de l'histogramme:
  
  - Une seule composante explique la majorité de la variabilité.
  - Il peut être intéressant de centrer-réduire les données pour mieux dégager la variabilité des données.

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Explication de la variabilité par les différentes composantes - avec center & scale true"}
mrna.pca = tune.pca(X = mrna.c, ncomp = 50, center = T, scale = T)
```

```{r}
mrna.pca$cum.var
```

Les 30 premières composantes expliquent 80% de la variabilité et elles sont donc sélectionnées.

```{r}
mrna.pca = pca(X = mrna.c, ncomp = 30, center = T, scale = T)
#plotVar(mrna.pca, comp = c(1,3), var.names = T)
var1pca = selectVar(mrna.pca, comp = 1)$value
name.var1pca = row.names(var1pca)[0:10]
```

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Projection des variables (ici les gènes) selon les composantes 1 et 2 d'une ACP"}
plotVar(mrna.pca, comp = c(1,2), var.names = T, col = "#8b1538")
```

Les dix variables contribuant le plus à l'axe 1 sont : `r name.var1pca`. Les graphiques représentant les variables sont actuellement très difficilement lisibles, on doit donc afficher les contributions des variables aux composantes à l'aide d'une commande.

```{r}
vec_col = as.numeric(as.factor(sample$Y))
```

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Projection des individus selon les composantes 1 et 2 d'une ACP"}
plotIndiv(mrna.pca, group = vec_col, legend = T, title = "")
```

On peut observer que la PCA sépare de façon assez distincte les individus des trois groupes selon les 2 premières composantes, malgré des frontières assez floues entre les groupes.

```{r}
spca.mrna = spca(mrna.c, ncomp = 3, center = TRUE, scale = TRUE,
                    keepX = c(10, 5, 15))
var1spca = selectVar(spca.mrna, comp = 1)$value
name.var1spca = row.names(var1spca)
var2spca = selectVar(spca.mrna, comp = 2)$value
name.var2spca = row.names(var2spca)
```

Les gènes sélectionnés par la spca pour la première composante sont : `r name.var1spca`.
Pour la seconde composante principale, on a retenu `r name.var2spca`.

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Projection des gènes principaux selon les composantes 1 et 2 d'une Sparse-PCA"}
plotVar(spca.mrna, comp = c(1,2), var.names = T, col = "#8b1538", cex=3.9)
```

## 2.1 Projection on Latent Structures

La PLS est une méthode statistique permettant de traiter différentes matrices de données. Contrairement à l'ACP, qui ne peut analyser qu'un jeu de données à la fois, on va ici pouvoir dégager des composantes - dites latentes - maximisant la covariance entre nos deux matrices d'entrée. Sur notre analyse, on va ainsi pouvoir dégager via les composantes les possibles corrélations entre l'expression génique et l'expression protéique.

```{r}
pls.result = pls(X = mrna.c, Y = prot.c, ncomp = 3)
```

```{r}
png("img/scatter_plot_pls.png")
plot(pls.result$variates$X[,2],pls.result$variates$X[,3], col = vec_col+1, ylab = "composante 3",xlab = "composante 2", main = "")
legend(x = 10, y = 8, legend = names(table(sample$Y)), col = c(2,3,4), lty = 1)
dev.off()

png("img/arrow_plot_pls.png")
plotArrow(pls.result, comp = c(1,3), X.label =  "comp1", Y.label = "comp3",col = vec_col+1, title = "")
legend(x = 5, y = 9, legend = names(table(sample$Y)), col = c(2,3,4), lty = 1)
dev.off()
```

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Projection des individus colorés en fonction de leur groupe selon les composantes 2 et 3 d'une PLS"}
knitr::include_graphics("img/scatter_plot_pls.png")
```

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Arrow plot des individus colorés en fonction de leur groupe selon les composantes 1 et 3 d'une PLS"}
knitr::include_graphics("img/arrow_plot_pls.png")
```

```{r, include=FALSE}
spls.result = spls(X = mrna.c, Y = prot.c, ncomp = 3, keepX  = c(10,5,1), keepY = c(9,5,1) )

var3spls = c(selectVar(spls.result, comp = 3)$X$name,
             selectVar(spls.result, comp = 3)$Y$name)

png("img/cim_plot_spls.png")
cim(spls.result)
dev.off()
```

Les variables retenues pour la troisième composante sont `r var3spls`.

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Matrice de corrélation entre l'expression des gènes et l'expression des protéines calculée à partir d'une Sparse-PLS"}
knitr::include_graphics("img/cim_plot_spls.png")
```


```{r}
network(spls.result,cutoff = 0.65, name.save = "img/network_plot_spls", save = "png")
```

```{r, include=T, fig.cap="Network plot des gènes et protéines les plus corrélés (|p| > 0.65) à partir des résultats d'une SPLS"}
knitr::include_graphics("img/network_plot_spls.png")
```

Sur la spls, on peut observer 7 clusters différents possédant une corrélation supérieure à 0.65 ou inférieure à -0.65 (3 protéines et 4 gènes).


## 2.2 Multiblock Projection on Latent Structures

```{r}
x.data = list(mrna = mrna.c, prot = prot.c)
y.data = as.matrix(as.data.frame(mirna.c))
```

```{r}
omics.block.pls = block.pls(X = x.data, Y = y.data, ncomp = 2)
omics.block.pls

selectVar(omics.block.pls, comp = 1)
selectVar(omics.block.pls, comp = 2)

network(omics.block.pls, cutoff = 0.65, name.save = "img/block-pls", save = "png")
```

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Résultats d'une block pls sur les protéines, mrna et mirna"}
plotVar(omics.block.pls)
plotLoadings(omics.block.pls)
knitr::include_graphics("img/block-pls.png")
```

```{r}
design = matrix(1, ncol = length(x.data), nrow = length(x.data), 
                dimnames = list(names(x.data), names(data)))
diag(design) = 0
design

list.keepX = list(mrna = c(10, 5), prot = c(9, 4))
list.keepY = c(7, 3)

omics.block.spls = block.spls(X = x.data, Y = y.data, ncomp = c(2), keepX = list.keepX, keepY = list.keepY, design = design) 

#omics.block.spls
#selectVar(omics.block.spls, comp = 1)
#selectVar(omics.block.spls, comp = 2)

network(omics.block.spls, cutoff = 0.65, name.save = "img/block-spls", save = "png")

mrna.selected = selectVar(omics.block.spls, comp = 1)$mrna$name
prot.selected = selectVar(omics.block.spls, comp = 1)$prot$name
mirna.selected = selectVar(omics.block.spls, comp = 1)$Y$name
```

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Résultats d'une block spls sur les protéines, mrna et mirna"}
plotVar(omics.block.spls)
plotLoadings(omics.block.spls)
knitr::include_graphics("img/block-spls.png")
```

Les variables sélectionnées sur la première composante sont:

  - Mrna: `r mrna.selected`
  - Protéine: `r prot.selected`
  - Mirna: `r mirna.selected`

## 3. Analyse supervisée : (s)PLS-DA

```{r}
plsda.mrna = plsda(mrna.c, sample$Y, ncomp = 2)
```

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Projection des individus selon les composantes 1 et 2 d'une PLS-DA"}
plotIndiv(plsda.mrna, legend = T, title = "")
```

Par rapport à la PCA, on peut considérer que la PLS-DA permet de mieux retrouver nos trois groupes d'échantillons sur ce graphique par rapport aux deux premières composantes principales. En effet, les trois groupes sont ici clairement distincts dans l'espace du graphique, et les frontières entre groupes sont bien plus marquées. Il semblerait donc que la variabilité des données calculée par la PLS-DA permet de mieux expliquer les différences génétiques entre les groupes de nos échantillons.

## 4. Analyse supervisée : block-(s)PLS-DA

```{r}
list.of.all = list(mrna = mrna.c, prot = prot.c, mirna = mirna.c)
block.splsda.all = block.splsda(list.of.all,
                                Y = sample$Y, ncomp = 5)
```

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Projection des individus selon les composantes 1 et 2 d'une block spls-da réalisée sur les gènes, mirna et protéines"}
plotIndiv(block.splsda.all, legend = T)
```

```{r}
perf.splsda = perf(block.splsda.all)
plot(perf.splsda)
```

```{r}
#Block PLS-DA avec keepX
list.keepX = list(mrna = c(15,10), prot = c(15,10), mirna = c(15,10))
block.splsda.keepX = block.splsda(list.of.all,
                                Y = sample$Y, ncomp = 2,
                                keepX = list.keepX)
```

```{r, include=T, out.width="80%", out.height="80%", fig.cap="Projection des individus selon les composantes 1 et 2 d'une block spls-da réalisée sur les gènes, mirna et protéines après sélection d'un nombre limité de variables pour chaque jeu de données"}
plotIndiv(block.splsda.keepX, legend = T)
```

```{r, include=T, out.width="100%", out.height="100%", fig.cap="Circosplot des protéines, mirna et mrna avec un cutoff de 0.5"}
# Circosplot
circosPlot(block.splsda.keepX, cutoff = 0.5)
```

# Partie III

## Question 1

Nous travaillons ici sur les effets de l'exposition à des polluants sur la santé des ours polaires. On a accès pour une vingtaine de trios (un mère et sa portée de deux enfants) à deux types de données omiques:

- Données transciptomiques
- Diverses mesures cliniques numériques - on suppose que ces données sont le poids, la taille & le taux d'exposition.

> Projection on Latent Structures

La PLS va nous permettre de dégager via les composantes les possibles corrélations entre l'expression génétique et les mesures cliniques.

```
pls.result = pls(X = rna, Y = data, ncomp = 3)
```

avec:

- rna: matrice des données transcriptomiques
- data: matrice mesures cliniques

> Projection on Latent Structures

Dans un deuxième temps, on va essayer de déterminer si les données transciptomiques et les diverses mesures cliniques (poides et taille) permettent de retrouver nos trois groupes d'échantillon qui sont :

- Ours faiblement exposé
- Ours moyennement exposé
- Ours fortement exposé

```
plsda.result = plsda(matrix, Y, ncomp = 2)
```

avec:

- matrix: matrice des données transcriptomiques, poids et taille
- Y: variable qualitative taux d'exposition à 3 classes - faible, moyen & élevé



transcriptomique
Groupe témoin échantillon sans pollution ?
traiter différemment la mère et les enfants
attention variations entre famille
évaluer la variance de nos échantillons
exposition mère impacte enfants ?

analyse en heatmap (spls, cim -> non, que transcriptome)
P.heatmap
acp ? variables
repérer les points communément sur ou sous exprimés


## Question 2

volcano plot p-value up down des molécules
classification
diversité alpha beta (évaluation)
krone ? (semble pas ouf)

Nous travaillons ici sur des microbiotes de souris ayant subi ou non un traitement. On a accès pour chaque souris à deux types de données omiques : métagénomiques (données 16S du microbiote) et métabolomiques (décompte de molécules du métabolome).
Donc -> pls ou pls-da
covariance entre data métagénome et métabolome
analyse individuelle sur métagénome -> diversité alpha / béta, composition métagénome

Il est aussi nécessaire dans ce cas d'effectuer une analyse multiomique. Les différentes informations apportées par les analyses simple-omique nous permettent de mettre en lumière les différences entre les groupes de souris, mais il pourrait être intéressant dans un second temps d'évaluer la covariance de ces données.
En effet, les données métagénomiques nous permettent de connaître la composition du microbiote des souris en terme de micro-organisme, et les données métabolomiques donnent une analyse sur la composition des molécules métaboliques du milieu intestinal probablement.
Pour déterminer plus précisément les impacts du traitement sur le milieu intestinal, il est donc nécessaire d'utiliser l'outil de "Projection on Latent Structure". On va ainsi pouvoir trouver les composantes maximisant la covariance entre métagénomique et métabolomique. On peut ainsi effectuer une sparse PLS sur les souris traitées d'un côté et non traitées de l'autre.
Un cim plot pourra ainsi être utilisé pour visualiser la variance entre nos différentes variables, ainsi qu'un network plot pour représenter les 16S et les métabolites les plus corrélés.
Ces deux représentations graphiques peuvent être utilisées pour les souris traitées et non traitées, pour ensuite comparer nos deux résultats, et ainsi évaluer si le traitement a une influence sur la covariance entre les données omiques.



